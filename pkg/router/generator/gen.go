// +build ignore

// This program generates a function map for templates. It can be invoked by
// running go generate at the root of the project.

package main

import (
	"fmt"
	"os"
	"path/filepath"
	"text/template"
	"time"
)

const (
	pluginsDir            = "./generator/plugins/"
	generatorPluginTarget = "./generator/plugins.go"
)

func main() {
	var imports []string

	err := filepath.Walk(pluginsDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			fmt.Printf("prevent panic by handling failure accessing a path %q: %v\n", path, err)
			return err
		}

		if info.IsDir() {
			if path != "pkg/generator/plugins" {
				imports = append(imports, info.Name())
			}
		}

		return nil
	})

	if err != nil {
		fmt.Printf("error walking the path %q: %v\n", pluginsDir, err)
		return
	}

	f, err := os.Create(generatorPluginTarget)
	if err != nil {
		fmt.Printf("error generating target file %q: %v\n", pluginsDir, err)
		return
	}
	defer f.Close()

	fmt.Println(imports)

	packageTemplate.Execute(f, struct {
		Timestamp time.Time
		Imports   []string
	}{
		Timestamp: time.Now(),
		Imports:   imports,
	})
}

var packageTemplate = template.Must(template.New("").Parse(`// Code generated by go generate; DO NOT EDIT.
// This file was generated by robots at
// {{ .Timestamp }}
// using data from
package generator

import (
	"html/template"
{{- range .Imports }}
	{{- if ne . "plugins" }}
	"github.com/ncatelli/mockserver/pkg/generator/plugins/{{ printf "%s" . }}"
	{{- end}}
{{- end }}
)

func PluginsFuncMap() template.FuncMap {
	return template.FuncMap{
{{- range .Imports }}
	{{- if ne . "plugins" }}
		{{ printf "%s" . }}.Generator{}.ID(): {{ printf "%s" . }}.Generator{}.Generate,
	{{- end}}
{{- end }}
    }
}
`))
